<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Orbital simulation with three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #f0f0f0;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			#time {
				position: absolute;
				top: 1em; width: 100%;
				padding: 5px;
			}

			#orbit {
				position: absolute;
				top: 2em; width: 100%;
				padding: 5px;
			}

			a {

				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">Asteroid simulation demo - powered by <a href="http://threejs.org" target="_blank">three.js</a></div>
		<div id="time"></div>
		<div id="orbit"></div>

		<script src="three.min.js"></script>
		<script src="stats.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="OBJLoader.js"></script>

		<script>

			var container, stats;
			var camera, scene, renderer;
			var group;
			var background;
			var mouseX = 0, mouseY = 0;
			var geometry;
			var cameraControls;
			var grids;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var viewScale = 100;

			var simTime;
			var realTime;
			var center_select = false;
			var select_idx = 0;
			var select_obj = null;
			var nlips_enable = true;
			var grid_enable = false;

			var up = false;
			var down = false;
			var left = false;
			var right = false;
			var prograde = false;
			var retrograde = false;
			var normal = false;
			var antinormal = false;
			var incline = false;
			var antiincline = false;

			var sun;
			var light;

			var selectedOrbitMaterial;

			var AU = 149597871; // Astronomical unit in kilometers
			var GMsun = 1.327124400e11 / AU / AU/ AU; // Product of gravitational constant (G) and Sun's mass (Msun)
			var epsilon = 1e-20; // Doesn't the machine epsilon depend on browsers!??
			var timescale = 1e0; // This is not a constant; it can be changed by the user
			var rad_per_deg = Math.PI / 180; // Radians per degrees

			function AxisAngleQuaternion(x, y, z, angle){
				var q = new THREE.Quaternion();
				q.setFromAxisAngle(new THREE.Vector3(x, y, z), angle);
				return q;
			}

			// CelestialBody class
			function CelestialBody(parent, position, vertex, orbitColor, GM){
				this.position = position;
				this.velocity = new THREE.Vector3();
				this.quaternion = new THREE.Quaternion();
				this.angularVelocity = new THREE.Vector3();
				this.vertex = vertex || new THREE.Vector3();
				if(orbitColor) this.orbitMaterial = new THREE.LineBasicMaterial({color: orbitColor});
				this.children = [];
				this.parent = parent;
				this.GM = GM || GMsun;
				if(parent) parent.children.push(this);
				this.radius = 1 / AU;
				this.controllable = false;
			}

			CelestialBody.prototype.init = function(){
				this.ascending_node = Math.random() * Math.PI * 2;
				this.epoch = Math.random();
				this.mean_anomaly = Math.random();
				this.update();
			};

			CelestialBody.prototype.get_eccentric_anomaly = function(time){
				// Calculates eccentric anomaly from mean anomaly in first order approximation
				// see http://en.wikipedia.org/wiki/Eccentric_anomaly
				var td = time - this.epoch;
				var period = 2 * Math.PI * Math.sqrt(Math.pow(this.semimajor_axis * AU, 3) / this.parent.GM);
				var now_anomaly = this.mean_anomaly + td * 2 * Math.PI / period;
				return now_anomaly + this.eccentricity * Math.sin(now_anomaly);
			};

			CelestialBody.prototype.getWorldPosition = function(){
				if(this.parent)
					return this.parent.getWorldPosition().clone().add(this.position);
				else
					return this.position;
			};

			// Update orbital elements from position and velocity.
			// The whole discussion is found in chapter 4.4 in
			// https://www.academia.edu/8612052/ORBITAL_MECHANICS_FOR_ENGINEERING_STUDENTS
			CelestialBody.prototype.update = function(){
				/// NLIPS: Non-Linear Inverse Perspective Scrolling
				/// Idea originally found in a game Homeworld that enable
				/// distant small objects to appear on screen in recognizable size
				/// but still renders in real scale when zoomed up.
				function nlipsFactor(o){
					if(!nlips_enable)
						return 1;
					var g_nlips_factor = 1e6;
					var d = o.vertex.distanceTo(camera.position) / viewScale;
					var f = d / o.radius * g_nlips_factor + 1;
					return f;
				}

				this.vertex.copy(this.getWorldPosition());
				if(select_obj && center_select)
					this.vertex.sub(select_obj.getWorldPosition());
				this.vertex.multiplyScalar(viewScale);

				if(this.model){
					this.model.scale.set(1,1,1).multiplyScalar(nlipsFactor(this));
					this.model.quaternion.copy(this.quaternion.clone().multiply(AxisAngleQuaternion(1, 0, 0, Math.PI / 2)));
				}

				// Angular momentum vectors
				var ang = this.velocity.clone().cross(this.position);
				var r = this.position.length();
				var v = this.velocity.length();
				// Node vector
				var N = (new THREE.Vector3(0, 0, 1)).cross(ang);
				// Eccentricity vector
				var e = this.position.clone().multiplyScalar(1 / this.parent.GM * ((v * v - this.parent.GM / r))).sub(this.velocity.clone().multiplyScalar(this.position.dot(this.velocity) / this.parent.GM));
				this.eccentricity = e.length();
				this.inclination = Math.acos(-ang.z / ang.length());
				// Avoid zero division
				if(N.lengthSq() <= epsilon)
					this.ascending_node = 0;
				else{
					this.ascending_node = Math.acos(N.x / N.length());
					if(N.y < 0) this.ascending_node = 2 * Math.PI - this.ascending_node;
				}
				this.semimajor_axis = 1 / (2 / r - v * v / this.parent.GM);

				// Rotation to perifocal frame
				var planeRot = AxisAngleQuaternion(0, 0, 1, this.ascending_node - Math.PI / 2).multiply(AxisAngleQuaternion(0, 1, 0, Math.PI - this.inclination));

				var headingApoapsis = -this.position.dot(this.velocity)/Math.abs(this.position.dot(this.velocity));

				// Avoid zero division and still get the correct answer when N == 0.
				// This is necessary to draw orbit with zero inclination and nonzero eccentricity.
				if(N.lengthSq() <= epsilon || e.lengthSq() <= epsilon)
					this.argument_of_perihelion = Math.atan2(-e.y, e.x);
				else
					this.argument_of_perihelion = Math.acos(N.dot(e) / N.length() / e.length());
				if(e.z < 0) this.argument_of_perihelion = 2 * Math.PI - this.argument_of_perihelion;

				// Total rotation of the orbit
				var rotation = planeRot.clone().multiply(AxisAngleQuaternion(0, 0, 1, this.argument_of_perihelion));

				// Show orbit information
				if(this === select_obj)
					document.getElementById('orbit').innerHTML = 'Orbit: '
						+ 'e=' + this.eccentricity.toFixed(10)
						+ ' a=' + this.semimajor_axis.toFixed(10)
						+ ' i=' + (this.inclination / Math.PI).toFixed(10)
						+ ' Omega=' + (this.ascending_node / Math.PI).toFixed(10)
						+ ' w=' + (this.argument_of_perihelion / Math.PI).toFixed(10)
						+ ' head=' + headingApoapsis.toFixed(5)
						+ ' omega=' + this.angularVelocity.x.toFixed(10) + ',' + this.angularVelocity.y.toFixed(10) + ',' + this.angularVelocity.z.toFixed(10);

				// Apply transformation to orbit mesh
				this.orbit.quaternion.copy(rotation);
				this.orbit.scale.x = this.semimajor_axis * viewScale * Math.sqrt(1. - this.eccentricity * this.eccentricity);
				this.orbit.scale.y = this.semimajor_axis * viewScale;
				this.orbit.position.copy(new THREE.Vector3(0, -this.semimajor_axis * this.eccentricity, 0).applyQuaternion(rotation).add(this.parent.getWorldPosition()));
				if(select_obj && center_select)
					this.orbit.position.sub(select_obj.getWorldPosition());
				this.orbit.position.multiplyScalar(viewScale);

				for(var i = 0; i < this.children.length; i++){
					var a = this.children[i];
					a.update();
				}

			};

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 300;
				camera.position.z = 1000;

				background = new THREE.Scene();
				background.rotation.x = Math.PI / 2;
				var loader = new THREE.TextureLoader();
				loader.load( 'hipparcoscyl1.jpg', function ( texture ) {

					var geometry = new THREE.SphereGeometry( 2, 20, 20 );

					var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5, depthTest: false, depthWrite: false, side: THREE.BackSide } );
					material.depthWrite = false;
					var mesh = new THREE.Mesh(geometry, material);
					background.add(mesh);

				} );

				scene = new THREE.Scene();

				group = new THREE.Object3D();
				scene.add( group );

				var material = new THREE.ParticleSystemMaterial( { size: 0.1 } );

				// Sun
				var Rsun = 695800. / 149597871. * viewScale;
				var sgeometry = new THREE.SphereGeometry( Rsun, 20, 20 );

				var mesh = new THREE.Mesh( sgeometry, material );
				group.add( mesh );

				// Sun light
				light = new THREE.PointLight( 0xffffff, 1, 0, 1e-6 );
				scene.add( light );
				scene.add( new THREE.AmbientLight( 0x202020 ) );

				var meshMaterial = new THREE.LineBasicMaterial({color: 0x3f3f3f});
				var meshGeometry = new THREE.Geometry();
				for(var x = -10; x <= 10; x++)
					meshGeometry.vertices.push( new THREE.Vector3( -10, x, 0 ), new THREE.Vector3(10, x, 0));
				for(var x = -10; x <= 10; x++)
					meshGeometry.vertices.push( new THREE.Vector3( x, -10, 0 ), new THREE.Vector3(x, 10, 0));
				grids = new THREE.Object3D();
				var mesh = new THREE.LineSegments(meshGeometry, meshMaterial);
				mesh.scale.x = mesh.scale.y = 100;
				grids.add(mesh);
				var mesh2 = new THREE.LineSegments(meshGeometry, meshMaterial);
				mesh2.scale.x = mesh2.scale.y = 10000 / AU * 100;
				grids.add(mesh2);

				function addAxis(axisVector, color){
					var axisXMaterial = new THREE.LineBasicMaterial({color: color});
					var axisXGeometry = new THREE.Geometry();
					axisXGeometry.vertices.push(new THREE.Vector3(0,0,0), axisVector);
					var axisX = new THREE.Line(axisXGeometry, axisXMaterial);
					axisX.scale.multiplyScalar(100);
					grids.add(axisX);
				}
				addAxis(new THREE.Vector3(100,0,0), 0xff0000);
				addAxis(new THREE.Vector3(0,100,0), 0x00ff00);
				addAxis(new THREE.Vector3(0,0,100), 0x0000ff);

				scene.add(grids);

				var orbitMaterial = new THREE.LineBasicMaterial({color: 0x3f3f7f});
				CelestialBody.prototype.orbitMaterial = orbitMaterial; // Default orbit material
				selectedOrbitMaterial = new THREE.LineBasicMaterial({color: 0xff7fff});
				var orbitGeometry = new THREE.Geometry();
				var curve = new THREE.EllipseCurve(0, 0, 1, 1,
					0, Math.PI * 2, false, 90);
				var path = new THREE.Path( curve.getPoints( 50 ) );
				var orbitGeometry = path.createPointsGeometry( 50 );

				geometry = new THREE.Geometry();

				// Add a planet having desired orbital elements. Note that there's no way to specify anomaly (phase) on the orbit right now.
				// It's a bit difficult to calculate in Newtonian dynamics simulation.
				function AddPlanet(semimajor_axis, eccentricity, inclination, ascending_node, argument_of_perihelion, color, GM, parent, texture, radius, angularVelocity, params){
					var rotation = AxisAngleQuaternion(0, 0, 1, ascending_node - Math.PI / 2)
						.multiply(AxisAngleQuaternion(0, 1, 0, Math.PI - inclination))
						.multiply(AxisAngleQuaternion(0, 0, 1, argument_of_perihelion));
					var vertex = new THREE.Vector3(0,0,0);
					var group = new THREE.Object3D();
					var ret = new CelestialBody(parent || sun, new THREE.Vector3(0, 1 - eccentricity, 0).multiplyScalar(semimajor_axis).applyQuaternion(rotation), group.position, color, GM);
					ret.model = group;
					ret.radius = radius;
//					geometry.vertices.push( vertex );
					scene.add( group );
					// earth

					if(texture){
						var loader = new THREE.TextureLoader();
						loader.load( texture || 'land_ocean_ice_cloud_2048.jpg', function ( texture ) {

							var geometry = new THREE.SphereGeometry( 1, 20, 20 );

							var material = new THREE.MeshLambertMaterial( { map: texture, color: 0xffffff, shading: THREE.FlatShading, overdraw: 0.5 } );
							var mesh = new THREE.Mesh( geometry, material );
							var radiusInAu = 100 * (radius || 6534) / AU;
							mesh.scale.set(radiusInAu, radiusInAu, radiusInAu);
							mesh.rotation.x = Math.PI / 2;
							group.add( mesh );

						} );
					}
					else if(params.modelName){
						var loader = new THREE.OBJLoader();
						loader.load( params.modelName, function ( object ) {
							var radiusInAu = 100 * (radius || 6534) / AU;
							object.scale.set(radiusInAu, radiusInAu, radiusInAu);
							group.add( object );
						} );
					}

					if(params && params.controllable)
						ret.controllable = params.controllable;

					// Orbital speed at given position and eccentricity can be calculated by v = \sqrt(\mu (2 / r - 1 / a))
					// https://en.wikipedia.org/wiki/Orbital_speed
					ret.velocity = new THREE.Vector3(1, 0, 0).multiplyScalar(Math.sqrt(ret.parent.GM * (2 / ret.position.length() - 1 / semimajor_axis))).applyQuaternion(rotation);
					ret.angularVelocity = angularVelocity || new THREE.Vector3(0,0,0);
					var orbitMesh = new THREE.Line(orbitGeometry, ret.orbitMaterial);
					ret.orbit = orbitMesh;
					scene.add(orbitMesh);
					ret.init();
					ret.update();
					return ret;
				}

				sun = new CelestialBody(null, new THREE.Vector3(), null, 0xffffff, this.parent.GM);
				var mercury = AddPlanet(0.387098, 0.205630, 7.005 * rad_per_deg, 48.331 * rad_per_deg, 29.124 * rad_per_deg, 0x3f7f7f, 22032 / AU / AU / AU, sun, 'mercury.jpg', 2439.7);
				var venus = AddPlanet(0.723332, 0.00677323, 3.39458 * rad_per_deg, 76.678 * rad_per_deg, 55.186 * rad_per_deg, 0x7f7f3f, 324859 / AU / AU / AU, sun, 'venus.jpg', 6051.8);
				// Earth is at 1 AU (which is the AU's definition) and orbits around the ecliptic.
				var earth = AddPlanet(1, 0.0167086, 0, -11.26064 * rad_per_deg, 114.20783 * rad_per_deg, 0x3f7f3f, 398600 / AU / AU / AU, sun, 'land_ocean_ice_cloud_2048.jpg', 6534, new THREE.Vector3(2 * Math.PI / ((23 * 60 + 56) * 60 + 4.10)));
				var sat = AddPlanet(10000 / AU, 0., 0, 0, 0, 0x3f7f7f, 100 / AU / AU / AU, earth, undefined, 0.1, null, {modelName: 'rocket.obj', controllable: true});
				var moon = AddPlanet(384399 / AU, 0.0167086, 0, -11.26064 * rad_per_deg, 114.20783 * rad_per_deg, 0x5f5f5f, this.parent.GM, earth, 'moon.png', 1737.1);
				var mars = AddPlanet(1.523679, 0.0935, 1.850 * rad_per_deg, 49.562 * rad_per_deg, 286.537 * rad_per_deg, 0x7f3f3f, 42828 / AU / AU / AU, sun, 'mars.jpg', 3389.5);
				select_obj = sat;
				center_select = true;
				camera.position.set(0.005, 0.003, 0.005);

				for ( i = 0; i < 10; i ++ ) {

					var angle = Math.random() * Math.PI * 2;
					var position = new THREE.Vector3();
					position.x = 0.1 * (Math.random() - 0.5);
					position.y = 0.1 * (Math.random() - 0.5) + 1;
					position.z = 0.1 * (Math.random() - 0.5);
					position.applyQuaternion(AxisAngleQuaternion(0, 0, 1, angle));

					position.multiplyScalar(2.5);
					var vertex = new THREE.Vector3(0,0,0);
					var asteroid = new CelestialBody(sun, position, vertex);
					asteroid.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.3 - 1, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3)
						.multiplyScalar(Math.sqrt(GMsun / position.length())).applyQuaternion(AxisAngleQuaternion(0, 0, 1, angle));

					geometry.vertices.push( vertex );

					var orbitMesh = new THREE.Line(orbitGeometry, asteroid.orbitMaterial);
					asteroid.orbit = orbitMesh;
					scene.add(orbitMesh);
					asteroid.orbits = [];

					asteroid.init();
					asteroid.update();

				}

				var particles = new THREE.ParticleSystem( geometry, material );

				scene.add( particles );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x000000 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;

				cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
				cameraControls.target.set( 0, 0, 0);
				cameraControls.maxDistance = 4000;
				cameraControls.minDistance = 1 / AU;
				cameraControls.update();

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'keydown', onKeyDown, false );
				window.addEventListener( 'keyup', onKeyUp, false );

				// Start the clock after the initialization is finished, otherwise
				// the very first frame of simulation can be long.
				simTime = new Date();
				realTime = simTime;
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				var now = new Date();
				var time = new Date(simTime.getTime() + (now.getTime() - realTime.getTime()) * timescale);
				var deltaTime = (time.getTime() - simTime.getTime()) * 1e-3;
				realTime = now;
				simTime = time;
				// Fills reading zero if the value is less than 10, making the returned string always two characters long.
				// Note that values not less than 100 or negative values are not guaranteed to be two characters wide.
				// This function is for date time formatting purpose only.
				function zerofill(v){
					if(v < 10)
						return "0" + v;
					else
						return v;
				}
				document.getElementById('time').innerHTML = 'Time: ' + time.getFullYear() + '/' + zerofill(time.getMonth() + 1) + '/' + zerofill(time.getDate())
					+ ' ' + zerofill(time.getHours()) + ':' + zerofill(time.getMinutes()) + ':' + zerofill(time.getSeconds())
					+ ' Timescale: ' + timescale.toPrecision(5);

				camera.near = Math.min(1, cameraControls.target.distanceTo(camera.position) / 10);
				camera.updateProjectionMatrix();

				var prevpos;
				if(center_select && select_obj){
					prevpos = select_obj.vertex.clone();
				}

				function simulateBody(children){
					for(var i = 0; i < children.length; i++){
						var a = children[i];
						var sl = a.position.lengthSq();
						if(sl !== 0){
							var angleAcceleration = 1e-1;
							var accel = a.position.clone().negate().normalize().multiplyScalar(deltaTime / div * a.parent.GM / sl);
							if(select_obj === a){
								if(up) select_obj.angularVelocity.add(new THREE.Vector3(1, 0, 0).applyQuaternion(select_obj.quaternion).multiplyScalar(angleAcceleration * deltaTime / div));
								if(down) select_obj.angularVelocity.add(new THREE.Vector3(-1, 0, 0).applyQuaternion(select_obj.quaternion).multiplyScalar(angleAcceleration * deltaTime / div));
								if(left) select_obj.angularVelocity.add(new THREE.Vector3(0, 0, 1).applyQuaternion(select_obj.quaternion).multiplyScalar(angleAcceleration * deltaTime / div));
								if(right) select_obj.angularVelocity.add(new THREE.Vector3(0, 0, -1).applyQuaternion(select_obj.quaternion).multiplyScalar(angleAcceleration * deltaTime / div));
								if(!up && !down && !left && !right && 1e-12 < select_obj.angularVelocity.lengthSq())
									select_obj.angularVelocity.add(select_obj.angularVelocity.clone().normalize().multiplyScalar(-angleAcceleration * deltaTime / div));
								if(prograde) select_obj.velocity.add(select_obj.velocity.clone().normalize().multiplyScalar(accelerate * deltaTime / div));
								if(retrograde) select_obj.velocity.add(select_obj.velocity.clone().normalize().multiplyScalar(-accelerate * deltaTime / div));
								if(normal) select_obj.velocity.add(select_obj.position.clone().normalize().multiplyScalar(accelerate * deltaTime / div));
								if(antinormal) select_obj.velocity.add(select_obj.position.clone().normalize().multiplyScalar(-accelerate * deltaTime / div));
								if(incline) select_obj.velocity.add(select_obj.velocity.clone().cross(select_obj.position).normalize().multiplyScalar(accelerate * deltaTime / div));
								if(antiincline) select_obj.velocity.add(select_obj.velocity.clone().cross(select_obj.position).normalize().multiplyScalar(-accelerate * deltaTime / div));
							}
							var dvelo = accel.clone().multiplyScalar(0.5);
							var vec0 = a.position.clone().add(a.velocity.clone().multiplyScalar(deltaTime / div / 2.));
							var accel1 = vec0.clone().negate().normalize().multiplyScalar(deltaTime / div * a.parent.GM / vec0.lengthSq());
							var velo1 = a.velocity.clone().add(dvelo);

							a.velocity.add(accel1);
							a.position.add(velo1.multiplyScalar(deltaTime / div));
							if(a.model){
								var axis = a.angularVelocity.clone().normalize();
								a.model.quaternion.multiply(AxisAngleQuaternion(axis.y, -axis.z, axis.x, a.angularVelocity.length() * deltaTime / div));
							}
						}
						simulateBody(a.children);
					}
				}

				var accelerate = 1e-15;
				var div = 100; // We should pick subdivide simulation step count by angular speed!
				for(var d = 0; d < div; d++){
					simulateBody(sun.children);
				}
				for(var i = 0; i < sun.children.length; i++){
					var a = sun.children[i];
					a.update();
				}

				var irotate = AxisAngleQuaternion(-1, 0, 0, Math.PI / 2);
				if(center_select && select_obj){
					// offset sun position
					group.position.copy(select_obj.getWorldPosition()).multiplyScalar(-viewScale);
					light.position.copy(select_obj.getWorldPosition()).multiplyScalar(-viewScale);
				}
				else{
					group.position.set(0,0,0).multiplyScalar(-viewScale);
					light.position.set(0,0,0);
				}

				geometry.verticesNeedUpdate = true;

				grids.visible = grid_enable;

//				camera.up.copy(new THREE.Vector3(0,0,1)); // This did't work with OrbitControls
				cameraControls.update();

				// Rotate axis around X to make Z point upward
				var rotate = AxisAngleQuaternion(1, 0, 0, Math.PI / 2);
				var oldPosition = camera.position.clone();
				camera.position.applyQuaternion(rotate);
				var oldQuaternion = camera.quaternion.clone();
				camera.quaternion.copy(rotate.multiply(camera.quaternion));

				var position = camera.position.clone();
				camera.position.set(0,0,0);
				renderer.render( background, camera);
				camera.position.copy(position);
				renderer.render( scene, camera );

				// Restore the original state because cameraControls expect these variables unchanged
				camera.quaternion.copy(oldQuaternion);
				camera.position.copy(oldPosition);
			}

			function onKeyDown( event ) {
				var char = String.fromCharCode(event.which || event.keyCode).toLowerCase();

				switch ( char ) {

					case 'i':
						if(select_obj === null)
							select_obj = sun.children[0];
						else{
							// Some objects do not have an orbit
							if(select_obj.orbit)
								select_obj.orbit.material = select_obj.orbitMaterial;
							var objs = select_obj.children;
							if(0 < objs.length){
								select_obj = objs[0];
							}
							else{
								var selected = false;
								var prev = select_obj;
								for(var parent = select_obj.parent; parent; parent = parent.parent){
									objs = parent.children;
									for(var i = 0; i < objs.length; i++){
										var o = objs[i];
										if(o === prev && i + 1 < objs.length){
											select_obj = objs[i+1];
											selected = true;
											break;
										}
									}
									if(selected)
										break;
									prev = parent;
								}
								if(!parent)
									select_obj = sun;
							}
						}
						if(select_obj.orbit)
							select_obj.orbit.material = selectedOrbitMaterial;
						break;

					case 'c':
						center_select = !center_select;
						break;

					case 'n': // toggle NLIPS
						nlips_enable = !nlips_enable;
						break;

					case 'g':
						grid_enable = !grid_enable;
						break;
				}

				if(select_obj && select_obj.controllable) switch( char ){
					case 'w': // prograde
						up = true;
//						prograde = true;
						break;
					case 's': // retrograde
						down = true;
//						retrograde = true;
						break;
					case 'q': // normal
						normal = true;
						break;
					case 'z': // normal negative
						antinormal = true;
						break;
					case 'a': // orbit plane normal
						left = true;
//						incline = true;
						break;
					case 'd': // orbit plane normal negative
						right = true;
//						antiincline = true;
						break;
				}

				// Annoying browser incompatibilities
				var code = event.which || event.keyCode;
				// Also support numpad plus and minus
				if(code === 107 || code === 187 && event.shiftKey)
					timescale *= 2;
				if(code === 109 || code === 189)
					timescale /= 2;

			}

			function onKeyUp( event ) {
				switch ( String.fromCharCode(event.which || event.keyCode).toLowerCase() ) {
					case 'w': // prograde
						up = false;
//						prograde = false;
						break;
					case 's':
						down = false;
//						retrograde = false;
						break;
					case 'q': // prograde
						normal = false;
						break;
					case 'z':
						antinormal = false;
						break;
					case 'a': // orbit plane normal
						left = false;
//						incline = false;
						break;
					case 'd': // orbit plane normal negative
						right = false;
//						antiincline = false;
						break;
				}
			}

			init();
			animate();


		</script>

	</body>
</html>
