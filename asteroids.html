<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Orbital simulation with three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #f0f0f0;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			#time {
				position: absolute;
				top: 1em; width: 100%;
				padding: 5px;
			}

			a {

				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">Asteroid simulation demo - powered by <a href="http://threejs.org" target="_blank">three.js</a></div>
		<div id="time"></div>

		<script src="three.min.js"></script>
		<script src="stats.min.js"></script>
		<script src="OrbitControls.js"></script>

		<script>

			var container, stats;
			var camera, scene, renderer;
			var group;
			var mouseX = 0, mouseY = 0;
			var geometry;
			var cameraControls;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var viewScale = 100;

			var startTime = new Date();
			var asteroids = [];
			var center_select = false;
			var select_idx = 0;
			var select_obj = null;

			var orbitMaterial, selectedOrbitMaterial;

			var AU = 149597871; // Astronomical unit in kilometers
			var GMsun = 1.327124400e11 / AU / AU; // Product of gravitational constant (G) and Sun's mass (Msun)

			function AxisAngleQuaternion(x, y, z, angle){
				var q = new THREE.Quaternion();
				q.setFromAxisAngle(new THREE.Vector3(x, y, z), angle);
				return q;
			}

			// Asteroid class
			function Asteroid(position, vertex){
				this.position = position;
				this.vertex = vertex;
				this.m_orients = [];
			}

			Asteroid.prototype.init = function(){
				this.ascending_node = Math.random() * Math.PI * 2;
				this.epoch = Math.random();
				this.mean_anomaly = Math.random();
				this.update();
			};

			Asteroid.prototype.get_eccentric_anomaly = function(time){
				// Calculates eccentric anomaly from mean anomaly in first order approximation
				// see http://en.wikipedia.org/wiki/Eccentric_anomaly
				var td = time - this.epoch;
				var period = 2 * Math.PI * Math.sqrt(Math.pow(this.semimajor_axis * AU, 3) / GMsun);
				var now_anomaly = this.mean_anomaly + td * 2 * Math.PI / period;
				return now_anomaly + this.eccentricity * Math.sin(now_anomaly);
			};

			Asteroid.prototype.update = function(){
			};

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 150;
				camera.position.z = 500;

				scene = new THREE.Scene();

				group = new THREE.Object3D();
				scene.add( group );

				var material = new THREE.ParticleSystemMaterial( { size: 5 } );

				// Sun
				var Rsun = 695800. / 149597871. * viewScale;
				var sgeometry = new THREE.SphereGeometry( Rsun, 20, 20 );

				var mesh = new THREE.Mesh( sgeometry, material );
				group.add( mesh );

				var meshMaterial = new THREE.LineBasicMaterial({color: 0x3f3f3f});
				var meshGeometry = new THREE.Geometry();
				for(var x = -10; x <= 10; x++)
					meshGeometry.vertices.push( new THREE.Vector3( -10, x, 0 ), new THREE.Vector3(10, x, 0));
				for(var x = -10; x <= 10; x++)
					meshGeometry.vertices.push( new THREE.Vector3( x, -10, 0 ), new THREE.Vector3(x, 10, 0));
				var mesh = new THREE.LineSegments(meshGeometry, meshMaterial);
				mesh.scale.x = mesh.scale.y = 100;
				scene.add(mesh);

				function addAxis(axisVector, color){
					var axisXMaterial = new THREE.LineBasicMaterial({color: color});
					var axisXGeometry = new THREE.Geometry();
					axisXGeometry.vertices.push(new THREE.Vector3(0,0,0), axisVector);
					var axisX = new THREE.Line(axisXGeometry, axisXMaterial);
					axisX.scale.multiplyScalar(100);
					scene.add(axisX);
				}
				addAxis(new THREE.Vector3(100,0,0), 0xff0000);
				addAxis(new THREE.Vector3(0,100,0), 0x00ff00);
				addAxis(new THREE.Vector3(0,0,100), 0x0000ff);

				orbitMaterial = new THREE.LineBasicMaterial({color: 0x3f3f7f});
				orbitMaterial.blending = THREE.AdditiveBlending;
				orbitMaterial.blendSrc = THREE.OneFactor;
				orbitMaterial.blendDst = THREE.OneFactor;
				selectedOrbitMaterial = new THREE.LineBasicMaterial({color: 0xff7fff});
				var orbitGeometry = new THREE.Geometry();
				var curve = new THREE.EllipseCurve(0, 0, 1, 1,
					0, Math.PI * 2, false, 90);
				var path = new THREE.Path( curve.getPoints( 50 ) );
				var orbitGeometry = path.createPointsGeometry( 50 );

				geometry = new THREE.Geometry();
				for ( i = 0; i < 100; i ++ ) {

					var vertex = new THREE.Vector3();
					vertex.x = Math.random() - 0.5;
					vertex.y = Math.random() - 0.5;
					vertex.z = Math.random() - 0.5;

					if(vertex.lengthSq() < 1){
						var asteroid = {position: vertex};
						vertex.multiplyScalar(100);
						vertex.x += 400;
						vertex.velo = new THREE.Vector3(0,0, Math.sqrt(300. / 400.));
						vertex.init = function(){
							this.argument_of_perihelion = Math.random() * Math.PI * 2;
							this.ascending_node = Math.random() * Math.PI * 2;
							this.inclination = Math.random() * 0.2;
							this.eccentricity = 0.4 * Math.random() * Math.random();
							this.semimajor_axis = (Math.random() + Math.random()) * 1 + 3.5;
							this.epoch = Math.random();
							this.mean_anomaly = Math.random();
						};
						vertex.get_eccentric_anomaly = function(time){
							// Calculates eccentric anomaly from mean anomaly in first order approximation
							// see http://en.wikipedia.org/wiki/Eccentric_anomaly
							var GMsun = 1.327124400e11; // Product of gravitational constant (G) and Sun's mass (Msun)
							var AU = 149597871; // Astronomical unit in kilometers
							var td = time - this.epoch;
							var period = 2 * Math.PI * Math.sqrt(Math.pow(this.semimajor_axis * AU, 3) / GMsun);
							var now_anomaly = this.mean_anomaly + td * 2 * Math.PI / period;
							return now_anomaly + this.eccentricity * Math.sin(now_anomaly);
						};

						vertex.init();
						geometry.vertices.push( vertex );

						function AxisAngleQuaternion(x, y, z, angle){
							var q = new THREE.Quaternion();
							q.setFromAxisAngle(new THREE.Vector3(x, y, z), angle);
							return q;
						}

						var orbitMesh = new THREE.Line(orbitGeometry, orbitMaterial);
						var ascend = AxisAngleQuaternion(0, 1, 0, vertex.ascending_node);
						var incline = AxisAngleQuaternion(1, 0, 0, vertex.inclination);
						var aop = AxisAngleQuaternion(0, 1, 0, vertex.argument_of_perihelion);
						var rotx = AxisAngleQuaternion(1, 0, 0, Math.PI / 2);
						var rotation = ascend.multiply(incline).multiply(aop).multiply(rotx);
						orbitMesh.quaternion.copy(rotation);
						orbitMesh.scale.x = vertex.semimajor_axis * viewScale;
						orbitMesh.scale.y = vertex.semimajor_axis * viewScale * (1. - vertex.eccentricity);
						offset = new THREE.Vector3(vertex.semimajor_axis * viewScale * vertex.eccentricity, 0, 0);
						offset.applyQuaternion(rotation);
						orbitMesh.position.copy(offset);
						vertex.orbit = orbitMesh;
						scene.add(orbitMesh);
						asteroid.orbit = orbitMesh;

						asteroid.init();
						asteroid.update();
						asteroids.push(asteroid);
					}

				}

				var particles = new THREE.ParticleSystem( geometry, material );

				scene.add( particles );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x000000 );
				renderer.setSize( window.innerWidth, window.innerHeight );

				cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
				cameraControls.target.set( 0, 40, 0);
				cameraControls.maxDistance = 4000;
				cameraControls.minDistance = 10;
				cameraControls.update();

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'keydown', onKeyDown, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				var now = new Date();
				var time = new Date(startTime.getTime() + (now.getTime() - startTime.getTime()) * 100);
				var deltaTime = (time.getTime() - lastTime.getTime()) * 1e-3;
				lastTime = time;
				document.getElementById('time').innerHTML = 'Time: ' + time.getFullYear() + '/' + time.getMonth() + '/' + time.getDate();
				var prevpos;
				if(center_select && select_obj){
					prevpos = select_obj.position.clone();
				}

				var div = 10;
				for(var d = 0; d < div; d++){
					for(var i = 0; i < asteroids.length; i++){
						var a = asteroids[i];
						var sl = a.position.lengthSq();
						if(sl !== 0){
							var accel = a.position.clone().negate().normalize().multiplyScalar(deltaTime / div * GMsun / sl);
							var dvelo = accel.clone().multiplyScalar(0.5);
							var vec0 = a.position.clone().add(a.velo.clone().multiplyScalar(deltaTime / div / 2.));
							var accel1 = vec0.clone().negate().normalize().multiplyScalar(deltaTime / div * GMsun / vec0.lengthSq());
							var velo1 = a.velo.clone().add(dvelo);

							a.velo.add(accel1);
							a.position.add(velo1.multiplyScalar(deltaTime / div));
						}
					}
				}
				for(var i = 0; i < asteroids.length; i++){
					var a = asteroids[i];
					a.update();
				}

				if(center_select && select_obj){
					cameraControls.target.copy(select_obj.position);
					// Move the camera along with the target motion.
					camera.position.add(select_obj.position.clone().sub(prevpos));
				}
				else{
					cameraControls.target.copy(new THREE.Vector3(0, 0, 0));
				}

				geometry.verticesNeedUpdate = true;

//				camera.up.copy(new THREE.Vector3(0,0,1)); // This did't work with OrbitControls
				cameraControls.update();

				// Rotate axis around X to make Z point upward
				var rotate = AxisAngleQuaternion(1, 0, 0, Math.PI / 2);
				var oldPosition = camera.position.clone();
				camera.position.applyQuaternion(rotate);
				var oldQuaternion = camera.quaternion.clone();
				camera.quaternion.copy(rotate.multiply(camera.quaternion));

				renderer.render( scene, camera );

				// Restore the original state because cameraControls expect these variables unchanged
				camera.quaternion.copy(oldQuaternion);
				camera.position.copy(oldPosition);
			}

			function onKeyDown( event ) {

				switch ( event.key ) {

					case 'i':
						if(select_obj === null)
							select_obj = asteroids[0];
						else{
							select_obj.orbit.material = orbitMaterial;
							select_idx = (select_idx + 1) % asteroids.length;
							select_obj = asteroids[select_idx];
						}
						select_obj.orbit.material = selectedOrbitMaterial;
						break;

					case 'c':
						center_select = !center_select;
						break;
				}

			}

			init();
			animate();


		</script>

	</body>
</html>
