<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Orbital simulation with three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #f0f0f0;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			#time {
				position: absolute;
				top: 1em; width: 100%;
				padding: 5px;
			}

			#orbit {
				position: absolute;
				top: 2em; width: 100%;
				padding: 5px;
			}

			a {

				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">Asteroid simulation demo - powered by <a href="http://threejs.org" target="_blank">three.js</a></div>
		<div id="time"></div>
		<div id="orbit"></div>

		<script src="three.min.js"></script>
		<script src="stats.min.js"></script>
		<script src="OrbitControls.js"></script>

		<script>

			var container, stats;
			var camera, scene, renderer;
			var group;
			var mouseX = 0, mouseY = 0;
			var geometry;
			var cameraControls;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var viewScale = 100;

			var simTime;
			var realTime;
			var asteroids = [];
			var center_select = false;
			var select_idx = 0;
			var select_obj = null;
			var debugMode = false;

			var prograde = false;
			var retrograde = false;
			var normal = false;
			var antinormal = false;
			var incline = false;
			var antiincline = false;

			var selectedOrbitMaterial;

			var AU = 149597871; // Astronomical unit in kilometers
			var GMsun = 1.327124400e11 / AU / AU/ AU; // Product of gravitational constant (G) and Sun's mass (Msun)
			var epsilon = 1e-20; // Doesn't the machine epsilon depend on browsers!??
			var timescale = 1e7; // This is not a constant; it can be changed by the user
			var rad_per_deg = Math.PI / 180; // Radians per degrees

			function AxisAngleQuaternion(x, y, z, angle){
				var q = new THREE.Quaternion();
				q.setFromAxisAngle(new THREE.Vector3(x, y, z), angle);
				return q;
			}

			// CelestialBody class
			function CelestialBody(position, vertex, orbitColor){
				this.position = position;
				this.velocity = new THREE.Vector3();
				this.vertex = vertex;
				if(orbitColor) this.orbitMaterial = new THREE.LineBasicMaterial({color: orbitColor});
			}

			CelestialBody.prototype.init = function(){
				this.ascending_node = Math.random() * Math.PI * 2;
				this.epoch = Math.random();
				this.mean_anomaly = Math.random();
				this.update();
			};

			CelestialBody.prototype.get_eccentric_anomaly = function(time){
				// Calculates eccentric anomaly from mean anomaly in first order approximation
				// see http://en.wikipedia.org/wiki/Eccentric_anomaly
				var td = time - this.epoch;
				var period = 2 * Math.PI * Math.sqrt(Math.pow(this.semimajor_axis * AU, 3) / GMsun);
				var now_anomaly = this.mean_anomaly + td * 2 * Math.PI / period;
				return now_anomaly + this.eccentricity * Math.sin(now_anomaly);
			};

			// Update orbital elements from position and velocity.
			// The whole discussion is found in chapter 4.4 in
			// https://www.academia.edu/8612052/ORBITAL_MECHANICS_FOR_ENGINEERING_STUDENTS
			CelestialBody.prototype.update = function(){
				this.vertex.copy(this.position).multiplyScalar(viewScale);
				// Angular momentum vectors
				var ang = this.velo.clone().cross(this.position);
				var r = this.position.length();
				var v = this.velo.length();
				// Node vector
				var N = (new THREE.Vector3(0, 0, 1)).cross(ang);
				// Eccentricity vector
				var e = this.position.clone().multiplyScalar(1 / GMsun * ((v * v - GMsun / r))).sub(this.velo.clone().multiplyScalar(this.position.dot(this.velo) / GMsun));
				this.eccentricity = e.length();
				this.inclination = Math.acos(ang.z / ang.length());
				// Avoid zero division
				if(N.lengthSq() <= epsilon)
					this.ascending_node = 0;
				else{
					this.ascending_node = Math.acos(N.x / N.length());
					if(N.y < 0) this.ascending_node = 2 * Math.PI - this.ascending_node;
				}
				this.semimajor_axis = 1 / (2 / r - v * v / GMsun);

				// Rotation to perifocal frame
				var planeRot = AxisAngleQuaternion(0, 0, 1, this.ascending_node - Math.PI / 2).multiply(AxisAngleQuaternion(0, 1, 0, this.inclination));

				var headingApoapsis = -this.position.dot(this.velo)/Math.abs(this.position.dot(this.velo));

				// Avoid zero division and still get the correct answer when N == 0.
				// This is necessary to draw orbit with zero inclination and nonzero eccentricity.
				if(N.lengthSq() <= epsilon || e.lengthSq() <= epsilon)
					this.argument_of_perihelion = Math.atan2(e.y, e.x);
				else
					this.argument_of_perihelion = Math.acos(N.dot(e) / N.length() / e.length());
				if(e.z < 0) this.argument_of_perihelion = 2 * Math.PI - this.argument_of_perihelion;

				// DEBUG: Update orbit candidates
				if(debugMode){
					for (var i = 0; i < 2; i++) {
						var argument_of_perihelion;
						// Avoid zero division and still get the correct answer when N == 0
						// This is necessary to draw orbit with zero inclination and nonzero eccentricity.
						if(N.lengthSq() <= epsilon || e.lengthSq() <= epsilon)
							argument_of_perihelion = Math.atan2(e.y, e.x);
						else
							rgument_of_perihelion = Math.acos(N.dot(e) / N.length() / e.length());
						if(0 < i) argument_of_perihelion = 2 * Math.PI - argument_of_perihelion;

						var debugRotation = planeRot.clone().multiply(AxisAngleQuaternion(0, 0, 1, argument_of_perihelion));
						this.orbits[i].quaternion.copy(debugRotation);
						this.orbits[i].scale.x = this.semimajor_axis * viewScale * Math.sqrt(1. - this.eccentricity * this.eccentricity);
						this.orbits[i].scale.y = this.semimajor_axis * viewScale;
						this.orbits[i].position.copy(new THREE.Vector3(0, -this.semimajor_axis * viewScale * this.eccentricity, 0).applyQuaternion(debugRotation));
					}
				}

				// Total rotation of the orbit
				var rotation = planeRot.clone().multiply(AxisAngleQuaternion(0, 0, 1, this.argument_of_perihelion));

				// Show orbit information
				if(this === select_obj)
					document.getElementById('orbit').innerHTML = 'Orbit: '
						+ 'e=' + this.eccentricity.toFixed(10)
						+ ' a=' + this.semimajor_axis.toFixed(10)
						+ ' i=' + (this.inclination / Math.PI).toFixed(10)
						+ ' Omega=' + (this.ascending_node / Math.PI).toFixed(10)
						+ ' w=' + (this.argument_of_perihelion / Math.PI).toFixed(10)
						+ ' head=' + headingApoapsis.toFixed(5);

				// Apply transformation to orbit mesh
				this.orbit.quaternion.copy(rotation);
				this.orbit.scale.x = this.semimajor_axis * viewScale * Math.sqrt(1. - this.eccentricity * this.eccentricity);
				this.orbit.scale.y = this.semimajor_axis * viewScale;
				this.orbit.position.copy(new THREE.Vector3(0, -this.semimajor_axis * viewScale * this.eccentricity, 0).applyQuaternion(rotation));
			};

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 300;
				camera.position.z = 1000;

				scene = new THREE.Scene();

				group = new THREE.Object3D();
				scene.add( group );

				var material = new THREE.ParticleSystemMaterial( { size: 5 } );

				// Sun
				var Rsun = 695800. / 149597871. * viewScale;
				var sgeometry = new THREE.SphereGeometry( Rsun, 20, 20 );

				var mesh = new THREE.Mesh( sgeometry, material );
				group.add( mesh );

				var meshMaterial = new THREE.LineBasicMaterial({color: 0x3f3f3f});
				var meshGeometry = new THREE.Geometry();
				for(var x = -10; x <= 10; x++)
					meshGeometry.vertices.push( new THREE.Vector3( -10, x, 0 ), new THREE.Vector3(10, x, 0));
				for(var x = -10; x <= 10; x++)
					meshGeometry.vertices.push( new THREE.Vector3( x, -10, 0 ), new THREE.Vector3(x, 10, 0));
				var mesh = new THREE.LineSegments(meshGeometry, meshMaterial);
				mesh.scale.x = mesh.scale.y = 100;
				scene.add(mesh);

				function addAxis(axisVector, color){
					var axisXMaterial = new THREE.LineBasicMaterial({color: color});
					var axisXGeometry = new THREE.Geometry();
					axisXGeometry.vertices.push(new THREE.Vector3(0,0,0), axisVector);
					var axisX = new THREE.Line(axisXGeometry, axisXMaterial);
					axisX.scale.multiplyScalar(100);
					scene.add(axisX);
				}
				addAxis(new THREE.Vector3(100,0,0), 0xff0000);
				addAxis(new THREE.Vector3(0,100,0), 0x00ff00);
				addAxis(new THREE.Vector3(0,0,100), 0x0000ff);

				var orbitMaterial = new THREE.LineBasicMaterial({color: 0x3f3f7f});
				CelestialBody.prototype.orbitMaterial = orbitMaterial; // Default orbit material
				selectedOrbitMaterial = new THREE.LineBasicMaterial({color: 0xff7fff});
				var orbitGeometry = new THREE.Geometry();
				var curve = new THREE.EllipseCurve(0, 0, 1, 1,
					0, Math.PI * 2, false, 90);
				var path = new THREE.Path( curve.getPoints( 50 ) );
				var orbitGeometry = path.createPointsGeometry( 50 );

				geometry = new THREE.Geometry();

				// Add a planet having desired orbital elements. Note that there's no way to specify anomaly (phase) on the orbit right now.
				// It's a bit difficult to calculate in Newtonian dynamics simulation.
				function AddPlanet(semimajor_axis, eccentricity, inclination, ascending_node, argument_of_perihelion, color){
					var rotation = AxisAngleQuaternion(0, 0, 1, ascending_node - Math.PI / 2)
						.multiply(AxisAngleQuaternion(0, 1, 0, inclination))
						.multiply(AxisAngleQuaternion(0, 0, 1, argument_of_perihelion));
					var vertex = new THREE.Vector3(0,0,0);
					var ret = new CelestialBody(new THREE.Vector3(0, 1 - eccentricity, 0).multiplyScalar(semimajor_axis).applyQuaternion(rotation), vertex, color);
					geometry.vertices.push( vertex );
					// Orbital speed at given position and eccentricity can be calculated by v = \sqrt(\mu (2 / r - 1 / a))
					// https://en.wikipedia.org/wiki/Orbital_speed
					ret.velo = new THREE.Vector3(1, 0, 0).multiplyScalar(Math.sqrt(GMsun * (2 / ret.position.length() - 1 / semimajor_axis))).applyQuaternion(rotation);
					var orbitMesh = new THREE.Line(orbitGeometry, ret.orbitMaterial);
					ret.orbit = orbitMesh;
					scene.add(orbitMesh);
					ret.init();
					ret.update();
					asteroids.push(ret);
					return ret;
				}

				var mercury = AddPlanet(0.387098, 0.205630, 7.005 * rad_per_deg, 48.331 * rad_per_deg, 29.124 * rad_per_deg, 0x3f7f7f);
				var venus = AddPlanet(0.723332, 0.00677323, 3.39458 * rad_per_deg, 76.678 * rad_per_deg, 55.186 * rad_per_deg, 0x7f7f3f);
				// Earth is at 1 AU (which is the AU's definition) and orbits around the ecliptic.
				var earth = AddPlanet(1, 0.0167086, 0, -11.26064 * rad_per_deg, 114.20783 * rad_per_deg, 0x3f7f3f);
				var mars = AddPlanet(1.523679, 0.0935, 1.850 * rad_per_deg, 49.562 * rad_per_deg, 286.537 * rad_per_deg, 0x7f3f3f);

				for ( i = 0; i < 10; i ++ ) {

					var angle = Math.random() * Math.PI * 2;
					var position = new THREE.Vector3();
					position.x = 0.1 * (Math.random() - 0.5);
					position.y = 0.1 * (Math.random() - 0.5) + 1;
					position.z = 0.1 * (Math.random() - 0.5);
					position.applyQuaternion(AxisAngleQuaternion(0, 0, 1, angle));

					position.multiplyScalar(2.5);
					var vertex = new THREE.Vector3(0,0,0);
					var asteroid = new CelestialBody(position, vertex);
					asteroid.velo = new THREE.Vector3((Math.random() - 0.5) * 0.3 + 1, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.3)
						.multiplyScalar(Math.sqrt(GMsun / position.length())).applyQuaternion(AxisAngleQuaternion(0, 0, 1, angle));

					geometry.vertices.push( vertex );

					var orbitMesh = new THREE.Line(orbitGeometry, asteroid.orbitMaterial);
					asteroid.orbit = orbitMesh;
					scene.add(orbitMesh);
					asteroid.orbits = [];

					// DEBUG: draw candidates of orbits
					for(var j = 0; j < 2; j++){
						var orbitMesh = new THREE.Line(orbitGeometry, asteroid.orbitMaterial);
						orbitMesh.visible = debugMode;
						asteroid.orbits[j] = orbitMesh;
						scene.add(orbitMesh);
					}

					asteroid.init();
					asteroid.update();
					asteroids.push(asteroid);

				}

				var particles = new THREE.ParticleSystem( geometry, material );

				scene.add( particles );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x000000 );
				renderer.setSize( window.innerWidth, window.innerHeight );

				cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
				cameraControls.target.set( 0, 40, 0);
				cameraControls.maxDistance = 4000;
				cameraControls.minDistance = 10;
				cameraControls.update();

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'keydown', onKeyDown, false );
				window.addEventListener( 'keyup', onKeyUp, false );

				// Start the clock after the initialization is finished, otherwise
				// the very first frame of simulation can be long.
				simTime = new Date();
				realTime = simTime;
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				var now = new Date();
				var time = new Date(simTime.getTime() + (now.getTime() - realTime.getTime()) * timescale);
				var deltaTime = (time.getTime() - simTime.getTime()) * 1e-3;
				realTime = now;
				simTime = time;
				// Fills reading zero if the value is less than 10, making the returned string always two characters long.
				// Note that values not less than 100 or negative values are not guaranteed to be two characters wide.
				// This function is for date time formatting purpose only.
				function zerofill(v){
					if(v < 10)
						return "0" + v;
					else
						return v;
				}
				document.getElementById('time').innerHTML = 'Time: ' + time.getFullYear() + '/' + zerofill(time.getMonth() + 1) + '/' + zerofill(time.getDate())
					+ ' ' + zerofill(time.getHours()) + ':' + zerofill(time.getMinutes()) + ':' + zerofill(time.getSeconds())
					+ ' Timescale: ' + timescale.toPrecision(5);
				var prevpos;
				if(center_select && select_obj){
					prevpos = select_obj.vertex.clone();
				}

				var accelerate = 1e-15;
				var div = 10;
				for(var d = 0; d < div; d++){
					for(var i = 0; i < asteroids.length; i++){
						var a = asteroids[i];
						var sl = a.position.lengthSq();
						if(sl !== 0){
							var accel = a.position.clone().negate().normalize().multiplyScalar(deltaTime / div * GMsun / sl);
							if(select_obj === a){
								if(prograde) select_obj.velo.add(select_obj.velo.clone().normalize().multiplyScalar(accelerate * deltaTime / div));
								if(retrograde) select_obj.velo.add(select_obj.velo.clone().normalize().multiplyScalar(-accelerate * deltaTime / div));
								if(normal) select_obj.velo.add(select_obj.position.clone().normalize().multiplyScalar(accelerate * deltaTime / div));
								if(antinormal) select_obj.velo.add(select_obj.position.clone().normalize().multiplyScalar(-accelerate * deltaTime / div));
								if(incline) select_obj.velo.add(select_obj.velo.clone().cross(select_obj.position).normalize().multiplyScalar(accelerate * deltaTime / div));
								if(antiincline) select_obj.velo.add(select_obj.velo.clone().cross(select_obj.position).normalize().multiplyScalar(-accelerate * deltaTime / div));
							}
							var dvelo = accel.clone().multiplyScalar(0.5);
							var vec0 = a.position.clone().add(a.velo.clone().multiplyScalar(deltaTime / div / 2.));
							var accel1 = vec0.clone().negate().normalize().multiplyScalar(deltaTime / div * GMsun / vec0.lengthSq());
							var velo1 = a.velo.clone().add(dvelo);

							a.velo.add(accel1);
							a.position.add(velo1.multiplyScalar(deltaTime / div));
						}
					}
				}
				for(var i = 0; i < asteroids.length; i++){
					var a = asteroids[i];
					a.update();
				}

				var irotate = AxisAngleQuaternion(-1, 0, 0, Math.PI / 2);
				if(center_select && select_obj){
					var rvertex = select_obj.vertex.clone().applyQuaternion(irotate);
					cameraControls.target.copy(rvertex);
					// Move the camera along with the target motion.
					camera.position.add(rvertex.sub(prevpos.applyQuaternion(irotate)));
				}
				else{
					cameraControls.target.copy(new THREE.Vector3(0, 0, 0));
				}

				geometry.verticesNeedUpdate = true;

//				camera.up.copy(new THREE.Vector3(0,0,1)); // This did't work with OrbitControls
				cameraControls.update();

				// Rotate axis around X to make Z point upward
				var rotate = AxisAngleQuaternion(1, 0, 0, Math.PI / 2);
				var oldPosition = camera.position.clone();
				camera.position.applyQuaternion(rotate);
				var oldQuaternion = camera.quaternion.clone();
				camera.quaternion.copy(rotate.multiply(camera.quaternion));

				renderer.render( scene, camera );

				// Restore the original state because cameraControls expect these variables unchanged
				camera.quaternion.copy(oldQuaternion);
				camera.position.copy(oldPosition);
			}

			function onKeyDown( event ) {

				switch ( event.key ) {

					case 'i':
						if(select_obj === null)
							select_obj = asteroids[0];
						else{
							select_obj.orbit.material = select_obj.orbitMaterial;
							select_idx = (select_idx + 1) % asteroids.length;
							select_obj = asteroids[select_idx];
						}
						select_obj.orbit.material = selectedOrbitMaterial;
						break;

					case 'c':
						center_select = !center_select;
						break;

					case 'D':
						debugMode = !debugMode;
						for(var i = 0; i < asteroids.length; i++){
							asteroids[i].orbits[0].visible = debugMode;
							asteroids[i].orbits[1].visible = debugMode;
						}
						break;

					case 'w': // prograde
						prograde = true;
						break;
					case 's': // retrograde
						retrograde = true;
						break;
					case 'q': // normal
						normal = true;
						break;
					case 'z': // normal negative
						antinormal = true;
						break;
					case 'a': // orbit plane normal
						incline = true;
						break;
					case 'd': // orbit plane normal negative
						antiincline = true;
						break;

					// Also support numpad plus and minus
					case '+': case 'Add':
						timescale *= 2;
						break;
					case '-': case 'Subtract':
						timescale /= 2;
						break;
				}

			}

			function onKeyUp( event ) {
				switch ( event.key ) {
					case 'w': // prograde
						prograde = false;
						break;
					case 's':
						retrograde = false;
						break;
					case 'q': // prograde
						normal = false;
						break;
					case 'z':
						antinormal = false;
						break;
					case 'a': // orbit plane normal
						incline = false;
						break;
					case 'd': // orbit plane normal negative
						antiincline = false;
						break;
				}
			}

			init();
			animate();


		</script>

	</body>
</html>
